# universe.py

from cosmic_resonance import CosmicResonance
from cosmic_dna_planets import CosmicDNA, PlanetarySystem
import numpy as np

class Universe:
    def __init__(self, universe_id: int, initial_conditions: dict, vibrational_frequency: float, parent_dna: str = None):
        """
        Inicializa um universo com suas propriedades básicas, Ressonância Cósmica,
        DNA Cósmico e um Sistema Planetário.

        Args:
            universe_id (int): Identificador único do universo.
            initial_conditions (dict): Dicionário com densidades iniciais (matéria, radiação).
            vibrational_frequency (float): A frequência vibracional intrínseca deste universo.
            parent_dna (str, optional): O DNA do universo 'pai' para herança. Defaults to None.
        """
        self.universe_id = universe_id
        self.matter_density = initial_conditions.get('matter_density', 0.3)
        self.radiation_density = initial_conditions.get('radiation_density', 0.001)

        self.cosmic_resonance = CosmicResonance(universe_id, vibrational_frequency=vibrational_frequency)
        self.cosmic_dna = CosmicDNA(parent_dna) # Inclui o DNA Cósmico
        self.planetary_system = PlanetarySystem(num_planets=2, universe_vibrational_frequency=vibrational_frequency) # Inclui planetas

        self.hubble_constant = self._calculate_hubble_initial()
        self.time = 0.0

        # Históricos para análise
        self.hubble_history = [self.hubble_constant]
        self.phi_history = [self.cosmic_resonance.phi]
        self.rho_phi_history = [self.cosmic_resonance.get_energy_density_phi()]
        self.symbolic_entropy_history = [0.0]
        self.average_planet_complexity_history = [0.0]


    def _calculate_hubble_initial(self) -> float:
        """
        Calcula a constante de Hubble inicial com base nas densidades iniciais.
        """
        rho_total = self.matter_density + self.radiation_density + self.cosmic_resonance.get_energy_density_phi()
        G = 6.674e-11 # Constante gravitacional universal.
        return np.sqrt((8 * np.pi * G / 3) * rho_total)

    def _update_hubble_constant(self):
        """
        Atualiza a constante de Hubble do universo.
        """
        G = 6.674e-11
        rho_phi = self.cosmic_resonance.get_energy_density_phi()
        rho_total = self.matter_density + self.radiation_density + rho_phi
        self.hubble_constant = np.sqrt((8 * np.pi * G / 3) * rho_total)

    def _calculate_symbolic_entropy_feedback(self) -> float:
        """
        Calcula feedback de complexidade/entropia simbólica de forma dinâmica.
        Agora, a amplitude das oscilações de phi é um fator!
        """
        # Usamos a amplitude do phi atual como uma proxy para "agitação" ou complexidade informacional
        # Um valor absoluto para garantir positividade no feedback.
        # Adicionamos um pequeno valor base para sempre haver algum feedback.
        feedback = np.abs(self.cosmic_resonance.phi) * 0.1 + 0.01
        # Podemos adicionar também a complexidade média dos planetas como um fator
        feedback += self.planetary_system.get_average_complexity() * 0.1
        return min(feedback, 1.0) # Limita o feedback a um máximo de 1.0

    def simulate_quantum_entanglement(self, other_universes: list):
        """
        Placeholder para simular feedback quântico e entrelaçamento entre universos.
        Esta é uma funcionalidade avançada e conceitual.
        """
        # Ideia: Universos entrelaçados podem ter seus phi's ou vibrational_frequencies
        # sutilmente ajustados com base nos estados dos outros.
        # Por exemplo, se um universo atingir um pico de consciência,
        # ele pode "ressonar" com outros universos entrelaçados.
        if self.universe_id == 0 and len(other_universes) > 1:
            # Exemplo: Universo 0 'sente' o phi médio dos outros universos
            avg_phi_others = np.mean([u.cosmic_resonance.phi for u in other_universes if u.universe_id != self.universe_id])
            # Uma pequena influência no phi_dot do universo atual
            self.cosmic_resonance.phi_dot += (avg_phi_others - self.cosmic_resonance.phi) * 0.001
            # print(f"DEBUG: Universo {self.universe_id} entrelaçado. Influência de {avg_phi_others:.4f}")


    def evolve_universe(self, time_step: float, all_universes: list = None):
        """
        Faz o universo evoluir por um dado passo de tempo.
        """
        self.time += time_step

        # 1. Simular entrelaçamento quântico (se houver outros universos)
        if all_universes:
            self.simulate_quantum_entanglement(all_universes)

        # 2. Obter feedback de complexidade (agora dinâmico)
        symbolic_entropy_feedback = self._calculate_symbolic_entropy_feedback()
        self.symbolic_entropy_history.append(symbolic_entropy_feedback)

        # 3. Evoluir o DNA Cósmico com base em uma métrica de sucesso (ex: feedback de entropia)
        self.cosmic_dna.evolve(symbolic_entropy_feedback)

        # 4. Atualizar o potencial V(phi) com base no feedback da consciência
        self.cosmic_resonance.update_potential_from_complexity(symbolic_entropy_feedback)

        # 5. Evoluir o campo escalar phi
        self.cosmic_resonance.evolve_phi(self.hubble_constant)

        # 6. Atualizar a constante de Hubble
        self._update_hubble_constant()

        # 7. Atualizar a complexidade dos planetas
        # Usamos o Rho_phi como proxy para a dinâmica do campo escalar para influenciar os planetas
        self.planetary_system.update_planets_complexity(self.cosmic_resonance.rho_phi_history[-1])
        self.average_planet_complexity_history.append(self.planetary_system.get_average_complexity())

        # 8. Registrar histórico
        self.hubble_history.append(self.hubble_constant)
        self.phi_history.append(self.cosmic_resonance.phi)
        self.rho_phi_history.append(self.cosmic_resonance.get_energy_density_phi())
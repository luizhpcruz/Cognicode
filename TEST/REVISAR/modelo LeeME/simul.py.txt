import numpy as np
import pandas as pd
import emcee
import scipy.integrate as integrate
from scipy.linalg import cholesky, solve_triangular
import matplotlib.pyplot as plt
import corner
import requests
from io import StringIO
import os

c = 299792.458  # km/s

def hubble_wcdm(z, H0, Om, w):
    return H0 * np.sqrt(Om * (1+z)**3 + (1 - Om) * (1+z)**(3*(1+w)))

def comoving_distance(z, H0, Om, w):
    def integrand(zp):
        return c / hubble_wcdm(zp, H0, Om, w)
    return integrate.quad(integrand, 0, z)[0]

def angular_distance(z, H0, Om, w):
    return comoving_distance(z, H0, Om, w) / (1 + z)

def log_likelihood_hz(params, data):
    H0, Om, w = params
    H_pred = np.array([hubble_wcdm(z, H0, Om, w) for z in data['z']])
    residual = data['Hz'] - H_pred
    try:
        L = cholesky(data['cov'], lower=True)
        alpha = solve_triangular(L, residual, lower=True)
        return -0.5 * np.dot(alpha, alpha)
    except:
        return -0.5 * np.sum((residual / np.sqrt(np.diag(data['cov'])))**2)

def log_likelihood_sne(params, data):
    H0, Om, w = params
    mb_pred = []
    for z in data['z']:
        dL = (1 + z) * comoving_distance(z, H0, Om, w)
        mb_pred.append(5 * np.log10(dL) + 25)
    residual = data['mb'] - np.array(mb_pred)
    try:
        L = cholesky(data['cov'], lower=True)
        alpha = solve_triangular(L, residual, lower=True)
        return -0.5 * np.dot(alpha, alpha)
    except:
        return -0.5 * np.sum((residual / np.sqrt(np.diag(data['cov'])))**2)

# Esboço simples para garantir correção de sintaxe
def dummy_main():
    print("Código corrigido com sucesso.")

if __name__ == "__main__":
    dummy_main()
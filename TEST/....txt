import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

# === 1. Carregar os dados ===
df = pd.read_csv("pantheon_data.csv")
z = df["zHD"].values
mu_obs = df["mu"].values
mu_err = df["muerr"].values

# === 2. Definir o modelo ΛCDM com termo Rond(z) ===
def mu_lcdm_mod(z, H0, Omega_m, Rond_0=0.0198, n=-3.0):
    c = 299792.458  # velocidade da luz em km/s
    Omega_lambda = 1.0 - Omega_m
    def E(z):
        return np.sqrt(Omega_m * (1 + z)**3 + Omega_lambda + Rond_0 * (1 + z)**n)
    integral = np.array([np.trapz(1.0 / E(np.linspace(0, zi, 1000)), np.linspace(0, zi, 1000)) for zi in z])
    d_L = (c / H0) * (1 + z) * integral  # distância em Mpc
    mu = 5 * np.log10(d_L) + 25
    return mu

# === 3. Ajustar o modelo modificado aos dados ===
popt_mod, pcov_mod = curve_fit(lambda z, H0, Omega_m: mu_lcdm_mod(z, H0, Omega_m), z, mu_obs, sigma=mu_err, absolute_sigma=True, p0=[70, 0.3])
H0_mod, Omega_m_mod = popt_mod
mu_model_mod = mu_lcdm_mod(z, H0_mod, Omega_m_mod)

# === 4. Calcular o erro quadrático médio ===
mse_mod = np.mean((mu_obs - mu_model_mod)**2)

# === 5. Exibir os resultados ===
print(f"Parâmetros ajustados (modelo modificado):")
print(f"H0 = {H0_mod:.2f} km/s/Mpc")
print(f"Omega_m = {Omega_m_mod:.3f}")
print(f"Erro quadrático médio (MSE): {mse_mod:.2f}")

# === 6. Plotar os resultados ===
plt.errorbar(z, mu_obs, yerr=mu_err, fmt='o', label='Observado', markersize=4, alpha=0.6)
plt.plot(z, mu_model_mod, label='Modelo ΛCDM Modificado', color='green')
plt.xlabel("Redshift (z)")
plt.ylabel("Módulo de distância (μ)")
plt.title("Ajuste do modelo ΛCDM modificado aos dados do Pantheon+")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()
